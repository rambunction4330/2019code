package frc.team4330.robot.IO


import edu.wpi.first.vision.VisionPipeline
import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import java.util.*

/**
 * GripPipeline class.
 *
 *
 * An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
class GripPipeline : VisionPipeline {

    //Outputs
    private val hsvThresholdOutput = Mat()
    private val findContoursOutput = ArrayList<MatOfPoint>()
    private val filterContoursOutput = ArrayList<MatOfPoint>()

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    override fun process(source0: Mat) {
        // Step HSV_Threshold0:
        val hsvThresholdHue = doubleArrayOf(50.179856115107924, 84.47098976109214)
        val hsvThresholdSaturation = doubleArrayOf(0.0, 104.87201365187714)
        val hsvThresholdValue = doubleArrayOf(126.12410071942448, 255.0)
        hsvThreshold(source0, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput)

        // Step Find_Contours0:
        val findContoursInput = hsvThresholdOutput
        val findContoursExternalOnly = true
        findContours(findContoursInput, findContoursExternalOnly, findContoursOutput)

        // Step Filter_Contours0:
        val filterContoursContours = findContoursOutput
        val filterContoursMinArea = 5.0
        val filterContoursMinPerimeter = 10.0
        val filterContoursMinWidth = 10.0
        val filterContoursMaxWidth = 1000.0
        val filterContoursMinHeight = 10.0
        val filterContoursMaxHeight = 1000.0
        val filterContoursSolidity = doubleArrayOf(77.33812949640289, 100.0)
        val filterContoursMaxVertices = 1000000.0
        val filterContoursMinVertices = 0.0
        val filterContoursMinRatio = 0.0
        val filterContoursMaxRatio = 1000.0
        filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput)

    }

    /**
     * This method is a generated getter for the output of a HSV_Threshold.
     * @return Mat output from HSV_Threshold.
     */
    fun hsvThresholdOutput(): Mat {
        return hsvThresholdOutput
    }

    /**
     * This method is a generated getter for the output of a Find_Contours.
     * @return ArrayList<MatOfPoint> output from Find_Contours.
    </MatOfPoint> */
    fun findContoursOutput(): ArrayList<MatOfPoint> {
        return findContoursOutput
    }

    /**
     * This method is a generated getter for the output of a Filter_Contours.
     * @return ArrayList<MatOfPoint> output from Filter_Contours.
    </MatOfPoint> */
    fun filterContoursOutput(): ArrayList<MatOfPoint> {
        return filterContoursOutput
    }


    /**
     * Segment an image based on hue, saturation, and value ranges.
     *
     * @param input The image on which to perform the HSL threshold.
     * @param hue The min and max hue
     * @param sat The min and max saturation
     * @param val The min and max value
     * @param output The image in which to store the output.
     */
    private fun hsvThreshold(input: Mat, hue: DoubleArray, sat: DoubleArray, `val`: DoubleArray,
                             out: Mat) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV)
        Core.inRange(out, Scalar(hue[0], sat[0], `val`[0]),
                Scalar(hue[1], sat[1], `val`[1]), out)
    }

    /**
     * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
     * @param input The image on which to perform the Distance Transform.
     * @param type The Transform.
     * @param maskSize the size of the mask.
     * @param output The image in which to store the output.
     */
    private fun findContours(input: Mat, externalOnly: Boolean,
                             contours: MutableList<MatOfPoint>) {
        val hierarchy = Mat()
        contours.clear()
        val mode: Int
        if (externalOnly) {
            mode = Imgproc.RETR_EXTERNAL
        } else {
            mode = Imgproc.RETR_LIST
        }
        val method = Imgproc.CHAIN_APPROX_SIMPLE
        Imgproc.findContours(input, contours, hierarchy, mode, method)
    }


    /**
     * Filters out contours that do not meet certain criteria.
     * @param inputContours is the input list of contours
     * @param output is the the output list of contours
     * @param minArea is the minimum area of a contour that will be kept
     * @param minPerimeter is the minimum perimeter of a contour that will be kept
     * @param minWidth minimum width of a contour
     * @param maxWidth maximum width
     * @param minHeight minimum height
     * @param maxHeight maximimum height
     * @param Solidity the minimum and maximum solidity of a contour
     * @param minVertexCount minimum vertex Count of the contours
     * @param maxVertexCount maximum vertex Count
     * @param minRatio minimum ratio of width to height
     * @param maxRatio maximum ratio of width to height
     */
    private fun filterContours(inputContours: List<MatOfPoint>, minArea: Double,
                               minPerimeter: Double, minWidth: Double, maxWidth: Double, minHeight: Double, maxHeight: Double, solidity: DoubleArray, maxVertexCount: Double, minVertexCount: Double, minRatio: Double, maxRatio: Double, output: MutableList<MatOfPoint>) {
        val hull = MatOfInt()
        output.clear()
        //operation
        for (i in inputContours.indices) {
            val contour = inputContours[i]
            val bb = Imgproc.boundingRect(contour)
            if (bb.width < minWidth || bb.width > maxWidth) continue
            if (bb.height < minHeight || bb.height > maxHeight) continue
            val area = Imgproc.contourArea(contour)
            if (area < minArea) continue
            if (Imgproc.arcLength(MatOfPoint2f(*contour.toArray()), true) < minPerimeter) continue
            Imgproc.convexHull(contour, hull)
            val mopHull = MatOfPoint()
            mopHull.create(hull.size().height.toInt(), 1, CvType.CV_32SC2)
            var j = 0
            while (j < hull.size().height) {
                val index = hull.get(j, 0)[0].toInt()
                val point = doubleArrayOf(contour.get(index, 0)[0], contour.get(index, 0)[1])
                mopHull.put(j, 0, *point)
                j++
            }
            val solid = 100 * area / Imgproc.contourArea(mopHull)
            if (solid < solidity[0] || solid > solidity[1]) continue
            if (contour.rows() < minVertexCount || contour.rows() > maxVertexCount) continue
            val ratio = bb.width / bb.height.toDouble()
            if (ratio < minRatio || ratio > maxRatio) continue
            output.add(contour)
        }
    }

    companion object {

        init {
            System.loadLibrary(Core.NATIVE_LIBRARY_NAME)
        }
    }


}

